/-!
induction is very broad, can apply to any inductively definted object
simple inductive view of imperative language
empty, declaration, if/else
abstract syntax tree
Lean as very general purpose logic, minimalistic
everything as Pi and Sigma types

add inductive data types to get lean, modern proof assistants
but we still need another source of axioms: all inductively defined types come with axiom on how to prove forall

-/
#check False.rec
#check Bool.rec

/-!
Bool.rec.{u}
  {motive : Bool → Sort u} --
  (false : motive false) --goals: show each satisfy their motive
  (true : motive true)
  (t : Bool) : -- given any bool, simply apply motive and it works (given the previous proofs)
  motive t
-/

/-!
double negation can work because of the Bool constructor, unlike the general case
IMPORTANT: using !, the boolean negator, rather than ¬, the logical negator
induction for bool is just like case analysis, not a recursive constructor but still an inductively defined type
inductively defined type with no recursion is just case analysis, like so
core inductive property: the values are all values that can be generated by applying constructor a finite number of times
-/
example: ∀ (b : Bool), !!b = b :=
by
  intros b
  induction b
  repeat{rfl}

#check Nat.rec

/-!
Nat.rec.{u}
  {motive : Nat → Sort u} --first implicit arg, property trying to prove
  (zero : motive Nat.zero) --proof for property with zero
  (succ : (n : Nat) → motive n → motive (Nat.succ n)) --proof for property given a proof for predecessor
  (t : Nat) :
  motive t
-/

/-!
factorial example for Nats
-/

def fact : Nat → Nat
| Nat.zero => 1
| Nat.succ n' => (Nat.succ n') * (fact n')

#reduce fact 5

def fact_0 := 1
def fact_succ_n : (n:Nat) → (fact_n : Nat) → Nat
| n, fact_n => (Nat.succ n) * fact_n

#check (Nat.rec fact_0 fact_succ_n : Nat → Nat)

--def fact' : Nat → Nat:= Nat.rec fact_0 fact_succ_n --doesn't work in current version of lean

#reduce (Nat.rec fact_0 fact_succ_n : Nat → Nat) 5 -- but it does work

#check List.rec
#check List Nat

/-!
List.rec.{u_1, u}
 {α : Type u}
 {motive : List α → Sort u_1}
 (nil : motive [])
 (cons : (head : α) → (tail : List α) → motive tail → motive (head :: tail))
 (t : List α) : motive t
-/

def list_e_len := 0
def list_step {α:Type} : α → List α → Nat → Nat := λ _ _ c => 1+c --do this as hw

#check (List.rec 0 list_step)

def list_len (α : Type): List α → Nat
| List.
|

inductive Tree (α :Type) where
| empty : Tree α
| node (a:α) (l r : Tree α)

#check Tree.rec
